package com.pvs.spent.fragment

import android.os.Bundle
import android.view.*
import android.widget.ArrayAdapter
import androidx.core.widget.doOnTextChanged
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.pvs.spent.MyViewModel
import com.pvs.spent.R
import com.pvs.spent.databinding.FragmentAddExpenseBinding
import com.pvs.spent.data.Expense
import com.pvs.spent.data.CreationPeriod
import com.pvs.spent.viewbehavior.ViewBehavior


class AddExpenseFragment : Fragment() {

    private lateinit var binding: FragmentAddExpenseBinding
    private val viewModel: MyViewModel by viewModels()
    private val args: AddExpenseFragmentArgs by navArgs()


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(args.expenseToEdit != null)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        binding = FragmentAddExpenseBinding.inflate(inflater, container, false)

        // Nav-args
        val expenseToEdit = args.expenseToEdit
        val quickFillCategory = args.quickFillCategory

        // Automatically fill Expense fields
        if (expenseToEdit != null) {
            binding.expenseTitle.editText!!.setText(expenseToEdit.title)
            binding.expenseAmount.editText!!.setText(expenseToEdit.amount.toString())
            binding.categoryDropDownTitle.setText(expenseToEdit.ofCategory)
        }

        // Automatically fill Category field
        if (quickFillCategory != null) {
            binding.categoryDropDownTitle.setText(quickFillCategory)
        }

        // Add or update Expense
        binding.expenseAddConfirmFAB.setOnClickListener {

            val title = binding.expenseTitle.editText!!.text.toString().trim()
            val amount = binding.expenseAmount.editText!!.text.toString().trim()
            val ofCategory = binding.categoryDropDownTitle.text.toString().trim()

            if (title.isNotEmpty() && title.isNotBlank() && amount.isNotEmpty() && amount.isNotBlank() && ofCategory.isNotEmpty() && ofCategory.isNotBlank()) {

                when (expenseToEdit) {
                    null -> { // add
                        val expense = Expense(
                            ofUser = viewModel.userEmail(),
                            title = title,
                            amount = amount.toFloat(),
                            ofCategory = ofCategory,
                            createdOn = CreationPeriod.now()
                        )
                        println("testing purposes ${expense.createdOn}")
                        viewModel.addExpense(expense)
                    }
                    else -> { // edit
                        expenseToEdit.title = title.trim()
                        expenseToEdit.amount = amount.toFloat()
                        expenseToEdit.ofCategory = ofCategory
                        viewModel.mergeExpense(expenseToEdit)
                    }

                }

                findNavController().popBackStack()

            } else {

                ViewBehavior.tilErrorMsg(
                    binding.expenseTitle,
                    viewModel.isTitleValid(title),
                    "Please enter a valid title"
                )

                ViewBehavior.tilErrorMsg(
                    binding.expenseAmount,
                    viewModel.isAmountValid(amount),
                    "Please enter a valid number greater than zero"
                )

                ViewBehavior.tilErrorMsg(
                    binding.categoryDropDown,
                    viewModel.isTitleValid(ofCategory),
                    "Please select a category"
                )

            }

        }

        binding.expenseTitle.editText!!.doOnTextChanged { _, _, _, _ ->
            binding.expenseTitle.error = null
        }

        binding.expenseAmount.editText!!.doOnTextChanged { _, _, _, _ ->
            binding.expenseAmount.error = null
        }

        binding.categoryDropDownTitle.doOnTextChanged { _, _, _, _ ->
            binding.categoryDropDown.error = null
        }

        return binding.root

    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.menu_item_expense, menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {

        when (item.itemId) {

            R.id.delExpenseNew -> {
                viewModel.delExpense(args.expenseToEdit!!)
                findNavController().popBackStack()
            }

        }

        return super.onOptionsItemSelected(item)

    }

    override fun onResume() {

        super.onResume()

        viewModel.readAllCategory(viewModel.userEmail()).observe(viewLifecycleOwner) { allCats ->

            binding.categoryDropDownTitle.setAdapter(
                ArrayAdapter(
                    requireContext(),
                    R.layout.item_dropdown_category,
                    allCats.map { it.title }.filter { it != "Misc" }.toList()
                )
            )
        }

    }

}